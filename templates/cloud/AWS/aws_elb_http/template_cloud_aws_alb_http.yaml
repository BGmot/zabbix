zabbix_export:
  version: '6.0'
  date: '2024-02-02T15:33:23Z'
  groups:
    - uuid: c2c162144c2d4c5491c8801193af4945
      name: Templates/Cloud
  templates:
    - uuid: f59c8b4156ec4386a7c724534ddd384d
      template: 'AWS ELB Application Load Balancer by HTTP'
      name: 'AWS ELB Application Load Balancer by HTTP'
      description: |
        The template gets AWS ELB Application Load Balancer metrics and uses the script item to make HTTP requests to the CloudWatch API.
        Don't forget to read the README.md for the correct setup of the template.
        
        You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback
        
        Generated by official Zabbix template tool "Templator"
      groups:
        - name: Templates/Cloud
      items:
        - uuid: 4bd5c4e139374a60a42eb86a343f315e
          name: 'AWS ALB: Get alarms check'
          type: DEPENDENT
          key: aws.alb.alarms.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check result of the alarm data has been got correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.alb.get_alarms
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 3fd832d1a2cc4cff955554cbd8c4b3c7
              expression: 'length(last(/AWS ELB Application Load Balancer by HTTP/aws.alb.alarms.check))>0'
              name: 'AWS ALB: Failed to get alarms data'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 059b7697baba46b2a7f138a1011a0e0c
          name: 'AWS CloudWatch: Get ALB alarms data'
          type: SCRIPT
          key: aws.alb.get_alarms
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials is not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			host = service + '.' + region + '.amazonaws.com',
            			canonical_uri = '/',
            			canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            			signed_headers = 'content-encoding;host;x-amz-date',
            			canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest(),
            			url = 'https://' + host + canonical_uri + '?' + params;
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            
            		response = request.get(url);
            
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		if (response[0] === '<') {
            			try {
            				response = XML.toJson(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		if (response !== null) {
            			try {
            				response = JSON.parse(response);
            			}
            			catch (error) {
            				throw 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';
            			}
            		}
            
            		return response;
            	},
            
            	getAlarms: function () {
            		var payload = {
            			'Action': 'DescribeAlarms',
            			'Version': '2010-08-01',
            			'MaxRecords': 100
            		},
            			result = [];
            
            		while (payload.NextToken !== '') {
            			var alarms = AWS.getField(AWS.request('GET', AWS.params.region, 'monitoring', AWS.prepareParams(payload)), 'DescribeAlarmsResponse.DescribeAlarmsResult');
            			payload.NextToken = alarms.nextToken || '';
            			alarms_list = AWS.getField(alarms, 'MetricAlarms');
            			regex = /loadbalancer\/(.+)$/;
            
            			if (!Array.isArray(alarms_list))
            				alarms_list = [alarms_list]
            			alarms_list.forEach(function (alarm) {
            				var dimensions = alarm.Dimensions;
            
            				Zabbix.log(4, '[ AWS ELB ] dimensions: ' + JSON.stringify(dimensions));
            				if (Array.isArray(alarm.Metrics)) {
            					alarm.Metrics.forEach(function (metric) {
            						if (typeof metric.MetricStat === 'object' && metric.MetricStat !== null
            							&& typeof metric.MetricStat.Metric === 'object' && metric.MetricStat.Metric !== null
            							&& Array.isArray(metric.MetricStat.Metric.Dimensions)) {
            							dimensions = dimensions.concat(metric.MetricStat.Metric.Dimensions);
            						}
            					});
            				}
            				for (var i in dimensions) {
            					if (dimensions[i].Name === 'LoadBalancer' && dimensions[i].Value === AWS.params.arn.match(regex)[1]) {
            						result.push(alarm);
            						break;
            					}
            				}
            			});
            		}
            
            		return result;
            	}
            }
            
            try {
            	AWS.setParams(JSON.parse(value));
            
            	return JSON.stringify(AWS.getAlarms());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Alarms ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: 'DescribeAlarms API method: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DescribeAlarms.html'
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: 15s
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: cf1a45ea7ad74602b675d1fbe137c53d
          name: 'AWS ALB: Active Connection'
          type: DEPENDENT
          key: aws.elb.active_connection
          delay: '0'
          history: 7d
          description: 'The total number of concurrent TCP connections active from clients to the load balancer and from the load balancer to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ActiveConnectionCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 0f966c0ff2f344f58a5c049ea2bc503a
          name: 'AWS ALB: ELB Auth Error'
          type: DEPENDENT
          key: aws.elb.auth_error
          delay: '0'
          history: 7d
          description: |
            The number of user authentications that could not be completed because an authenticate action was misconfigured,
            the load balancer couldn't establish a connection with the IdP, or the load balancer couldn't complete the authentication flow due to an internal error.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthError")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: 5f516687f9364f2f87b7fd1d2cbc8054
          name: 'AWS ALB: ELB Auth Failure'
          type: DEPENDENT
          key: aws.elb.auth_failure
          delay: '0'
          history: 7d
          description: 'The number of user authentications that could not be completed because the IdP denied access to the user or an authorization code was used more than once.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthFailure")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: bfae078db4a14fd6a31b94e87552e430
          name: 'AWS ALB: ELB Auth Latency'
          type: DEPENDENT
          key: aws.elb.auth_latency
          delay: '0'
          history: 7d
          units: ms
          description: |
            The time elapsed, in milliseconds, to query the IdP for the ID token and user info.
            If one or more of these operations fail, this is the time to failure.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthLatency")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: authorization
        - uuid: 8562bd314951443faed4039c2c36b127
          name: 'AWS ALB: ELB Auth User Claims Size Exceeded'
          type: DEPENDENT
          key: aws.elb.auth_user_claims_size_exceeded
          delay: '0'
          history: 7d
          description: 'The number of times that a configured IdP returned user claims that exceeded 11K bytes in size.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ELBAuthUserClaimsSizeExceeded")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: authorization
            - tag: component
              value: errors
        - uuid: 4f06db3a2da446c28228a20ed04847e1
          name: 'AWS ALB: Consumed LCUs'
          type: DEPENDENT
          key: aws.elb.capacity_units
          delay: '0'
          history: 7d
          value_type: FLOAT
          description: |
            The number of load balancer capacity units (LCU) used by your load balancer.
            You pay for the number of LCUs that you use per hour.
            For more information, see Elastic Load Balancing pricing.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ConsumedLCUs")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: c7e81227b5a648de9413ffcb6b9746ee
          name: 'AWS ALB: Client TLS Negotiation Error'
          type: DEPENDENT
          key: aws.elb.client_tls_negotiation_error
          delay: '0'
          history: 7d
          description: |
            The number of TLS connections initiated by the client that did not establish a session with the load balancer due to a TLS error.
            Possible causes include a mismatch of ciphers or protocols or the client failing to verify the server certificate and closing the connection.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ClientTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: c7b4e867ff8246058d931ca76d18d4e7
          name: 'AWS ALB: Get metrics data'
          type: SCRIPT
          key: aws.elb.get_metrics
          delay: 0s;m/1
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            	request_period: 60,
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	renderMetricQuery: function (period, arn) {
            		var metrics_list = [
            			'ActiveConnectionCount:Sum',
            			'ClientTLSNegotiationErrorCount:Sum',
            			'ConsumedLCUs:Sum',
            			'DesyncMitigationMode_NonCompliant_Request_Count:Sum',
            			'HTTP_Fixed_Response_Count:Sum',
            			'HTTP_Redirect_Count:Sum',
            			'HTTP_Redirect_Url_Limit_Exceeded_Count:Sum',
            			'HTTPCode_ELB_3XX_Count:Sum',
            			'HTTPCode_ELB_4XX_Count:Sum',
            			'HTTPCode_ELB_5XX_Count:Sum',
            			'HTTPCode_ELB_500_Count:Sum',
            			'HTTPCode_ELB_502_Count:Sum',
            			'HTTPCode_ELB_503_Count:Sum',
            			'HTTPCode_ELB_504_Count:Sum',
            			'NewConnectionCount:Sum',
            			'ProcessedBytes:Sum',
            			'RejectedConnectionCount:Sum',
            			'RequestCount:Sum',
            			'RuleEvaluations:Sum',
            			'TargetResponseTime:Average',
            			'TargetTLSNegotiationErrorCount:Sum',
            			'TargetConnectionErrorCount:Sum',
            			'ELBAuthError:Sum',
            			'ELBAuthFailure:Sum',
            			'ELBAuthLatency:Sum',
            			'ELBAuthSuccess:Sum',
            			'ELBAuthUserClaimsSizeExceeded:Sum',
            		],
            			regex = /loadbalancer\/(.+)$/;
            
            		var metric_payload = [];
            		metrics_list.forEach(function (metric, index) {
            			var parts = metric.split(':', 2);
            			metric_payload.push({
            				'Id': 'm' + index,
            				'MetricStat': {
            					'Metric': {
            						'MetricName': parts[0],
            						'Namespace': 'AWS/ApplicationELB',
            						'Dimensions': [
            							{
            								'Name': 'LoadBalancer',
            								'Value': arn.match(regex)[1],
            							}
            						]
            					},
            					'Period': period,
            					'Stat': parts[1],
            				}
            			});
            		});
            
            		return metric_payload;
            
            	},
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, data) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            		else {
            			data = JSON.stringify(data)
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            
            		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			url = 'https://' + host + canonical_uri;
            
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            
            		url = 'https://' + host + '/';
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.post(url, data);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            		}
            
            		return JSON.parse(response);
            	},
            
            	getMetricsData: function () {
            		var end_time = Math.floor((new Date().getTime()) / 1000),
            			start_time = end_time - AWS.request_period * 60;
            		payload = {
            			'StartTime': start_time,
            			'EndTime': end_time,
            			'ScanBy': 'TimestampDescending',
            			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn),
            		}
            		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
            	}
            
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.getMetricsData());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Get metrics] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB Application Load balancer metrics.
            Full metrics list related to Application Load balancer: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
        - uuid: eabcf1ef1514451087d08d739cf55d94
          name: 'AWS ALB: ELB HTTP 3XX'
          type: DEPENDENT
          key: aws.elb.http_3xx
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 3XX redirection codes that originate from the load balancer.
            This count does not include response codes generated by targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_3XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 3xx
        - uuid: c714c1f2185b4b0b8b86e3ad336d7888
          name: 'AWS ALB: ELB HTTP 4XX'
          type: DEPENDENT
          key: aws.elb.http_4xx
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 4XX client error codes that originate from the load balancer.
            This count does not include response codes generated by targets.
            
            Client errors are generated when requests are malformed or incomplete.
            These requests were not received by the target, other than in the case where the load balancer returns an HTTP 460 error code.
            This count does not include any response codes generated by the targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_4XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 4xx
          triggers:
            - uuid: 922bd3ab505b420984c93dfdfc417a56
              expression: 'min(/AWS ELB Application Load Balancer by HTTP/aws.elb.http_4xx,5m)>{$AWS.HTTP.4XX.FAIL.MAX.WARN}'
              name: 'AWS ALB: Too many HTTP 4XX error codes'
              event_name: 'AWS ALB: Too many HTTP 4XX error codes (over {$AWS.HTTP.4XX.FAIL.MAX.WARN} for 5m)'''
              priority: WARNING
              description: '"Too many requests failed with HTTP 4XX code"'
              tags:
                - tag: scope
                  value: availability
        - uuid: 6395ef49a60546ec8d3ce117867cbb43
          name: 'AWS ALB: ELB HTTP 5XX'
          type: DEPENDENT
          key: aws.elb.http_5xx
          delay: '0'
          history: 7d
          description: |
            The number of HTTP 5XX server error codes that originate from the load balancer.
            This count does not include any response codes generated by the targets.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_5XX_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
          triggers:
            - uuid: 883fc396e7da4806943cd70688c057a3
              expression: 'min(/AWS ELB Application Load Balancer by HTTP/aws.elb.http_5xx,5m)>{$AWS.HTTP.5XX.FAIL.MAX.WARN}'
              name: 'AWS ALB: Too many HTTP 5XX error codes'
              event_name: 'AWS ALB: Too many HTTP 5XX error codes (over {$AWS.HTTP.5XX.FAIL.MAX.WARN} for 5m)'''
              priority: WARNING
              description: '"Too many requests failed with HTTP 5XX code"'
              tags:
                - tag: scope
                  value: availability
        - uuid: 7bf9230aa56b4196b386d23358da75ed
          name: 'AWS ALB: ELB HTTP 500'
          type: DEPENDENT
          key: aws.elb.http_500
          delay: '0'
          history: 7d
          description: 'The number of HTTP 500 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_500_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '500'
        - uuid: f89bee8030774615a132d25a6d1b7a2a
          name: 'AWS ALB: ELB HTTP 502'
          type: DEPENDENT
          key: aws.elb.http_502
          delay: '0'
          history: 7d
          description: 'The number of HTTP 502 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_502_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '502'
        - uuid: bca5eaf0b96c496395ed98e8d4705153
          name: 'AWS ALB: ELB HTTP 503'
          type: DEPENDENT
          key: aws.elb.http_503
          delay: '0'
          history: 7d
          description: 'The number of HTTP 503 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_503_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '503'
        - uuid: 5d1c57a6483c4b84b992f9677f6216c1
          name: 'AWS ALB: ELB HTTP 504'
          type: DEPENDENT
          key: aws.elb.http_504
          delay: '0'
          history: 7d
          description: 'The number of HTTP 504 error codes that originate from the load balancer.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTPCode_ELB_504_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
            - tag: http-code
              value: 5xx
            - tag: http-code
              value: '504'
        - uuid: 115bdaf06c554f9a8b3a486c28d218cd
          name: 'AWS ALB: HTTP Fixed Response'
          type: DEPENDENT
          key: aws.elb.http_fixed_response
          delay: '0'
          history: 7d
          description: 'The number of fixed-response actions that were successful.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Fixed_Response_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: responses
        - uuid: 4edc1d8d4eb84832996943ac571afb5f
          name: 'AWS ALB: HTTP Redirect'
          type: DEPENDENT
          key: aws.elb.http_redirect
          delay: '0'
          history: 7d
          description: 'The number of redirect actions that were successful.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Redirect_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
        - uuid: fbf24a4f2110416d973a8f11c8770d98
          name: 'AWS ALB: HTTP Redirect Url Limit Exceeded'
          type: DEPENDENT
          key: aws.elb.http_redirect_url_limit_exceeded
          delay: '0'
          history: 7d
          description: 'The number of redirect actions that couldn''t be completed because the URL in the response location header is larger than 8K Bytes.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "HTTP_Redirect_Url_Limit_Exceeded_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: http
        - uuid: 7fdd931458ba4fa5b3baff1d67e4a32f
          name: 'AWS ALB: Get metrics check'
          type: DEPENDENT
          key: aws.elb.metrics.check
          delay: '0'
          history: 7d
          trends: '0'
          value_type: CHAR
          description: 'Check result of the instance metric data has been got correctly.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - $.error
              error_handler: CUSTOM_VALUE
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: status
          triggers:
            - uuid: 70282eb6c0c442f9a4f4c49b10f54a4d
              expression: 'length(last(/AWS ELB Application Load Balancer by HTTP/aws.elb.metrics.check))>0'
              name: 'AWS ALB: Failed to get metrics data'
              priority: WARNING
              tags:
                - tag: scope
                  value: availability
        - uuid: 740872a3328e4c12827d8fcd16eb43ea
          name: 'AWS ALB: New Connection'
          type: DEPENDENT
          key: aws.elb.new_connection
          delay: '0'
          history: 7d
          description: 'The total number of new TCP connections established from clients to the load balancer and from the load balancer to targets.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "NewConnectionCount§")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 4e3cf684607741e39248929e6b917be7
          name: 'AWS ALB: Desync Mitigation Mode Non Compliant Request'
          type: DEPENDENT
          key: aws.elb.non_compliant_request
          delay: '0'
          history: 7d
          description: 'The number of requests that fail to comply with HTTP protocols.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "DesyncMitigationMode_NonCompliant_Request_Count")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 32b5fbc67cec4d739bbd95ba1cd77ab9
          name: 'AWS ALB: Processed Bytes'
          type: DEPENDENT
          key: aws.elb.processed_bytes
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: B
          description: |
            The total number of bytes processed by the load balancer over IPv4 and IPv6 (HTTP header and HTTP payload).
            This count includes traffic to and from clients and Lambda functions, and traffic from an Identity Provider (IdP) if user authentication is enabled.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "ProcessedBytes")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: capacity
        - uuid: ed3c4ebc1faf43ff9be134ae98aac0e9
          name: 'AWS ALB: Rejected Connection'
          type: DEPENDENT
          key: aws.elb.rejected_Connection
          delay: '0'
          history: 7d
          description: |
            The total number of bytes processed by the load balancer over IPv4 and IPv6 (HTTP header and HTTP payload).
            This count includes traffic to and from clients and Lambda functions, and traffic from an Identity Provider (IdP) if user authentication is enabled.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RejectedConnectionCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: connections
        - uuid: 4b5b059c30ef4f8bb4d11a273d071db1
          name: 'AWS ALB: Requests'
          type: DEPENDENT
          key: aws.elb.requests
          delay: '0'
          history: 7d
          description: |
            The number of requests processed over IPv4 and IPv6.
            This metric is only incremented for requests where the load balancer node was able to choose a target.
            Requests that are rejected before a target is chosen are not reflected in this metric.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RequestCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: requests
        - uuid: b5105b9e48f4482db42ff948f906be6f
          name: 'AWS ALB: Rule Evaluations'
          type: DEPENDENT
          key: aws.elb.rule_evaluations
          delay: '0'
          history: 7d
          description: 'The number of rules processed by the load balancer given a request rate averaged over an hour.'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "RuleEvaluations")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: requests
        - uuid: 09cd066b48544eb7ac818bc6171e3e87
          name: 'AWS ALB: Target Connection Error'
          type: DEPENDENT
          key: aws.elb.target_connection_error
          delay: '0'
          history: 7d
          description: |
            The number of connections that were not successfully established between the load balancer and target.
            This metric does not apply if the target is a Lambda function.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetConnectionErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 560c74f7011b4b9c821dfdf7f8d8e93a
          name: 'AWS ALB: Target Response Time'
          type: DEPENDENT
          key: aws.elb.target_response_time
          delay: '0'
          history: 7d
          value_type: FLOAT
          units: s
          description: |
            The time elapsed, in seconds, after the request leaves the load balancer until a response from the target is received.
            This is equivalent to the target_processing_time field in the access logs.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetResponseTime")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: responses
        - uuid: 66d56d14553d4de69a63745ab02f2611
          name: 'AWS ALB: Target TLS Negotiation Error'
          type: DEPENDENT
          key: aws.elb.target_tls_negotiation_error
          delay: '0'
          history: 7d
          description: |
            The number of TLS connections initiated by the load balancer that did not establish a session with the target.
            Possible causes include a mismatch of ciphers or protocols. This metric does not apply if the target is a Lambda function.
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$.[?(@.Label == "TargetTLSNegotiationErrorCount")].Values.first().first()'
              error_handler: DISCARD_VALUE
          master_item:
            key: aws.elb.get_metrics
          tags:
            - tag: component
              value: errors
        - uuid: 9b118d348b934146bab54e2df582e2b0
          name: 'AWS ALB: Get target groups'
          type: SCRIPT
          key: aws_elb_get_target_groups
          delay: 0s;m/30
          history: '0'
          trends: '0'
          value_type: TEXT
          params: |
            var AWS = {
            	params: {},
            
            	getField: function (data, path) {
            		var steps = path.split('.');
            		for (var i = 0; i < steps.length; i++) {
            			var step = steps[i];
            			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
            				throw 'Required field was not found: ' + path;
            			}
            
            			data = data[step];
            		}
            
            		return data;
            	},
            
            	setParams: function (params) {
            		AWS.params['proxy'] = params.proxy;
            		switch (AWS.getField(params, 'auth_type')) {
            			case 'role_base':
            				AWS.params['auth_type'] = 'role_base';
            				var request = new HttpRequest();
            				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            					request.setProxy(AWS.params.proxy);
            				}
            				var IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
            
            				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
            					throw 'Error getting security credentials from instance metadata. Role not found.';
            				}
            
            				credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
            
            				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
            					throw 'Error getting security credentials from instance metadata.';
            				}
            
            				try {
            					credentials = JSON.parse(credentials);
            				}
            				catch (error) {
            					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
            				}
            
            				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
            					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
            						throw 'Required credentials are not set: "' + field + '".';
            					};
            					AWS.params[field] = credentials[field];
            				});
            				break;
            			case 'access_key':
            			default:
            				AWS.params['auth_type'] = 'access_key';
            				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
            					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            						throw 'Required param is not set: "' + field + '".';
            					}
            					AWS.params[field] = params[field];
            				});
            		}
            		['region', 'arn'].forEach(function (field) {
            			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
            				throw 'Required param is not set: "' + field + '".';
            			}
            			AWS.params[field] = params[field];
            		});
            
            	},
            
            	sign: function (key, message) {
            		var hex = hmac('sha256', key, message);
            
            		if ((hex.length % 2) === 1) {
            			throw 'Invalid length of a hex string!';
            		}
            
            		var result = new Int8Array(hex.length / 2);
            		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
            			result[b] = parseInt(hex.substring(i, i + 2), 16);
            		}
            
            		return result;
            	},
            
            	prepareParams: function (params) {
            		var result = [];
            
            		Object.keys(params).sort().forEach(function (key) {
            			if (typeof params[key] !== 'object') {
            				result.push(key + '=' + encodeURIComponent(params[key]));
            			}
            			else {
            				result.push(prepareObject(key, params[key]));
            			}
            		});
            
            		return result.join('&');
            	},
            
            	request: function (method, region, service, params) {
            		if (typeof data === 'undefined' || data === null) {
            			data = '';
            		}
            		else {
            			data = JSON.stringify(data)
            		}
            		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
            			date = amzdate.replace(/T\d+Z/, ''),
            			canonical_uri = '/',
            			host = service + '.' + region + '.amazonaws.com';
            
            		if (AWS.params.auth_type === 'role_base') {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
            		} else {
            			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
            				signed_headers = 'content-encoding;host;x-amz-date';
            		}
            		canonical_request = method + '\n' + canonical_uri + '\n' + params + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
            			url = 'https://' + host + canonical_uri + '?' + params;
            		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
            			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
            			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
            
            		key = AWS.sign(key, region);
            		key = AWS.sign(key, service);
            		key = AWS.sign(key, 'aws4_request');
            
            		var request = new HttpRequest();
            
            		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
            			request.setProxy(AWS.params.proxy);
            		}
            		request.addHeader('x-amz-date: ' + amzdate);
            		request.addHeader('x-amz-content-sha256:' + sha256(data));
            		request.addHeader('Accept: application/json');
            		request.addHeader('Content-Type: application/json');
            		request.addHeader('Content-Encoding: amz-1.0');
            		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
            		if (AWS.params.auth_type === 'role_base')
            			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
            
            		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
            		response = request.get(url);
            		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
            		if (request.getStatus() !== 200) {
            			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
            
            		}
            		return JSON.parse(response);
            	},
            
            	listTargetGroups: function () {
            		var lld_array = [],
            			regex = /targetgroup\/(.+)$/,
            			payload = {
            				'Action': 'DescribeTargetGroups',
            				'LoadBalancerArn': AWS.params.arn,
            				'Version': '2015-12-01',
            
            			};
            		targets = AWS.getField(AWS.request('GET', AWS.params.region, 'elasticloadbalancing', AWS.prepareParams(payload)), 'DescribeTargetGroupsResponse.DescribeTargetGroupsResult.TargetGroups');
            
            		if (!Array.isArray(targets))
            			targets = [targets]
            
            		targets.forEach(function (targets) {
            			lld_array.push(
            				{
            					target_name: AWS.getField(targets, 'TargetGroupName'),
            					target_arn: AWS.getField(targets, 'TargetGroupArn').match(regex)[0],
            					type: AWS.getField(targets, 'TargetType'),
            					protocol: AWS.getField(targets, 'Protocol'),
            					region: AWS.params.region
            				}
            			)
            		});
            
            		return lld_array;
            	}
            };
            
            try {
            	AWS.setParams(JSON.parse(value));
            	return JSON.stringify(AWS.listTargetGroups());
            }
            catch (error) {
            	error += (String(error).endsWith('.')) ? '' : '.';
            	Zabbix.log(3, '[ AWS ELB Target groups ] ERROR: ' + error);
            
            	return JSON.stringify({ 'error': error });
            }
          description: |
            Get ELB Target group.
            DescribeTargetGroups: https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html
          preprocessing:
            - type: CHECK_NOT_SUPPORTED
              parameters:
                - ''
          timeout: '{$AWS.DATA.TIMEOUT}'
          parameters:
            - name: AccessKeyId
              value: '{$AWS.ACCESS.KEY.ID}'
            - name: arn
              value: '{$AWS.ELB.ARN}'
            - name: auth_type
              value: '{$AWS.AUTH_TYPE}'
            - name: proxy
              value: '{$AWS.PROXY}'
            - name: region
              value: '{$AWS.REGION}'
            - name: SecretAccessKey
              value: '{$AWS.SECRET.ACCESS.KEY}'
          tags:
            - tag: component
              value: raw
      discovery_rules:
        - uuid: 065ef42ebea5448896db5fcc5baa2f81
          name: 'ALB alarms discovery'
          type: DEPENDENT
          key: aws.alb.alarms.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
                formulaid: A
              - macro: '{#ALARM_NAME}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
                formulaid: C
              - macro: '{#ALARM_SERVICE_NAMESPACE}'
                value: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: D
          description: 'Discovery instance alarms.'
          item_prototypes:
            - uuid: fca522690827426bb63f93e90d98aa54
              name: 'AWS ALB Alarms: ["{#ALARM_NAME}"]: Get metrics'
              type: DEPENDENT
              key: 'aws.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              delay: '0'
              history: '0'
              trends: '0'
              value_type: TEXT
              description: 'Get alarm metrics about the state and its reason.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.AlarmName == "{#ALARM_NAME}")].first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: aws.alb.get_alarms
              tags:
                - tag: component
                  value: raw
            - uuid: 3ef62eb9b0824f8ea3c2c1e8e15ce1fd
              name: 'AWS ALB Alarms: ["{#ALARM_NAME}"]: State'
              type: DEPENDENT
              key: 'aws.alb.alarm.state["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The state value for the alarm. Possible values: 0 (OK), 1 (INSUFFICIENT_DATA), 2 (ALARM).
                Alarm description:
                {#ALARM_DESCRIPTION}
              valuemap:
                name: 'Alarm state'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateValue
                  error_handler: CUSTOM_VALUE
                  error_handler_params: '3'
                - type: JAVASCRIPT
                  parameters:
                    - |
                      var state = ['OK', 'INSUFFICIENT_DATA', 'ALARM'];
                      
                      return state.indexOf(value.trim()) === -1 ? 255 : state.indexOf(value.trim());
              master_item:
                key: 'aws.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
              trigger_prototypes:
                - uuid: b8bbc96a20bc4ab393d1fa76a3cf5254
                  expression: 'last(/AWS ELB Application Load Balancer by HTTP/aws.alb.alarm.state["{#ALARM_NAME}"])=1'
                  name: 'AWS ALB Alarms: "{#ALARM_NAME}" has ''Insufficient data'' state'
                  priority: INFO
                  tags:
                    - tag: scope
                      value: notice
            - uuid: 8839a61a10f7453ebfdcae0ef16eb37c
              name: 'AWS ALB Alarms: ["{#ALARM_NAME}"]: State reason'
              type: DEPENDENT
              key: 'aws.alb.alarm.state_reason["{#ALARM_NAME}"]'
              delay: '0'
              history: 7d
              trends: '0'
              value_type: TEXT
              description: |
                An explanation for the alarm state, in text format.
                Alarm description:
                {#ALARM_DESCRIPTION}
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - $.StateReason
                  error_handler: DISCARD_VALUE
                - type: DISCARD_UNCHANGED_HEARTBEAT
                  parameters:
                    - 3h
              master_item:
                key: 'aws.alb.alarm.get_metrics["{#ALARM_NAME}"]'
              tags:
                - tag: component
                  value: alarms
          trigger_prototypes:
            - uuid: a1b8587c80dd41ef8b185cf62e563bcb
              expression: 'last(/AWS ELB Application Load Balancer by HTTP/aws.alb.alarm.state["{#ALARM_NAME}"])=2 and length(last(/AWS ELB Application Load Balancer by HTTP/aws.alb.alarm.state_reason["{#ALARM_NAME}"]))>0'
              name: 'AWS ALB Alarms: "{#ALARM_NAME}" has ''Alarm'' state'
              priority: AVERAGE
              description: |
                Alarm "{#ALARM_NAME}" has 'Alarm' state. 
                Reason: {ITEM.LASTVALUE2}
              tags:
                - tag: scope
                  value: availability
          master_item:
            key: aws.alb.get_alarms
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  var result = [];
                  var alarms = JSON.parse(value);
                  
                  alarms.forEach(function(alarm) {
                  
                   result.push({
                  '{#ALARM_DESCRIPTION}': alarm.AlarmDescription !== null ? alarm.AlarmDescription : 'None' ,
                  '{#ALARM_NAME}': alarm.AlarmName,
                  '{#ALARM_PERIOD}': alarm.Period,
                  '{#METRIC_NAME}': alarm.MetricName,
                  '{#ALARM_SERVICE_NAMESPACE}': alarm.Namespace !== null ? alarm.Namespace : 'None'
                    });
                  });
                  
                  return JSON.stringify(result);
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
        - uuid: 1002081ffffd40828ff5419c50bc16d5
          name: 'Target groups discovery'
          type: DEPENDENT
          key: aws.elb.target_groups.discovery
          delay: '0'
          filter:
            evaltype: AND
            conditions:
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
                formulaid: A
              - macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
                value: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
                operator: NOT_MATCHES_REGEX
                formulaid: B
          description: 'Discovery {$AWS.ELB.TARGET.GROUP.NAME} target groups.'
          item_prototypes:
            - uuid: 21d1830526e14fb99b2288d79747d472
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Anomalous Host'
              type: DEPENDENT
              key: 'aws.elb.target_groups.anomalous_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of hosts detected with anomalies.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "AnomalousHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 306971d2e8fb441d8ae4a658b26304c3
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Get metrics'
              type: SCRIPT
              key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: 0s;m/5
              history: '0'
              trends: '0'
              value_type: TEXT
              params: |
                var AWS = {
                	params: {},
                	request_period: 60,
                
                	getField: function (data, path) {
                		var steps = path.split('.');
                		for (var i = 0; i < steps.length; i++) {
                			var step = steps[i];
                			if (typeof data !== 'object' || typeof data[step] === 'undefined') {
                				throw 'Required field was not found: ' + path;
                			}
                
                			data = data[step];
                		}
                
                		return data;
                	},
                
                	setParams: function (params) {
                		AWS.params['proxy'] = params.proxy;
                		switch (AWS.getField(params, 'auth_type')) {
                			case 'role_base':
                				AWS.params['auth_type'] = 'role_base';
                				var request = new HttpRequest();
                				if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                					request.setProxy(AWS.params.proxy);
                				}
                				var IamRoleName = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials');
                
                				if (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {
                					throw 'Error getting security credentials from instance metadata. Role not found.';
                				}
                
                				credentials = request.get('http://169.254.169.254/latest/meta-data/iam/security-credentials/' + encodeURI(IamRoleName));
                
                				if (request.getStatus() !== 200 || credentials === null || credentials === '') {
                					throw 'Error getting security credentials from instance metadata.';
                				}
                
                				try {
                					credentials = JSON.parse(credentials);
                				}
                				catch (error) {
                					throw 'Failed to parse response received from instance metadata. Check debug log for more information.';
                				}
                
                				['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {
                					if (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {
                						throw 'Required credentials are not set: "' + field + '".';
                					};
                					AWS.params[field] = credentials[field];
                				});
                				break;
                			case 'access_key':
                			default:
                				AWS.params['auth_type'] = 'access_key';
                				['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {
                					if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                						throw 'Required param is not set: "' + field + '".';
                					}
                					AWS.params[field] = params[field];
                				});
                		}
                		['region', 'arn','target_arn'].forEach(function (field) {
                			if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {
                				throw 'Required param is not set: "' + field + '".';
                			}
                			AWS.params[field] = params[field];
                		});
                
                	},
                
                	sign: function (key, message) {
                		var hex = hmac('sha256', key, message);
                
                		if ((hex.length % 2) === 1) {
                			throw 'Invalid length of a hex string!';
                		}
                
                		var result = new Int8Array(hex.length / 2);
                		for (var i = 0, b = 0; i < hex.length; i += 2, b++) {
                			result[b] = parseInt(hex.substring(i, i + 2), 16);
                		}
                
                		return result;
                	},
                
                	renderMetricQuery: function (period, arn, target_arn) {
                		var metrics_list = [
                			'HTTPCode_Target_2XX_Count:Sum',
                			'HTTPCode_Target_3XX_Count:Sum',
                			'HTTPCode_Target_4XX_Count:Sum',
                			'HTTPCode_Target_5XX_Count:Sum',
                			'HealthyHostCount:Average',
                			'UnHealthyHostCount:Average',
                			'HealthyStateRouting:Sum',
                			'UnhealthyStateRouting:Sum',
                			'UnhealthyRoutingRequestCount:Sum',
                			'HealthyStateDNS:Sum',
                			'UnhealthyStateDNS:Sum',
                			'RequestCountPerTarget:Sum',
                			'MitigatedHostCount:Average',
                			'AnomalousHostCount:Average',
                		],
                			regex = /loadbalancer\/(.+)$/;
                
                		var metric_payload = [];
                		metrics_list.forEach(function (metric, index) {
                			var parts = metric.split(':', 2);
                			metric_payload.push({
                				'Id': 'm' + index,
                				'MetricStat': {
                					'Metric': {
                						'MetricName': parts[0],
                						'Namespace': 'AWS/ApplicationELB',
                						'Dimensions': [
                							{
                								'Name': 'LoadBalancer',
                								'Value': arn.match(regex)[1],
                							},
                							{
                								'Name': 'TargetGroup',
                								'Value': target_arn
                							}
                						]
                					},
                					'Period': period,
                					'Stat': parts[1],
                				}
                			});
                		});
                
                		return metric_payload;
                
                	},
                	prepareParams: function (params) {
                		var result = [];
                
                		Object.keys(params).sort().forEach(function (key) {
                			if (typeof params[key] !== 'object') {
                				result.push(key + '=' + encodeURIComponent(params[key]));
                			}
                			else {
                				result.push(prepareObject(key, params[key]));
                			}
                		});
                
                		return result.join('&');
                	},
                
                	request: function (method, region, service, data) {
                		if (typeof data === 'undefined' || data === null) {
                			data = '';
                		}
                		else {
                			data = JSON.stringify(data)
                		}
                		var amzdate = (new Date()).toISOString().replace(/\.\d+Z/, 'Z').replace(/[-:]/g, ''),
                			date = amzdate.replace(/T\d+Z/, ''),
                			canonical_uri = '/',
                			host = service + '.' + region + '.amazonaws.com';
                
                		if (AWS.params.auth_type === 'role_base') {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n' + 'x-amz-security-token:' + AWS.params.Token + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';
                		} else {
                			var canonical_headers = 'content-encoding:amz-1.0\n' + 'host:' + host + '\n' + 'x-amz-date:' + amzdate + '\n',
                				signed_headers = 'content-encoding;host;x-amz-date';
                		}
                
                		canonical_request = method + '\n' + canonical_uri + '\n' + '\n' + canonical_headers + '\n' + signed_headers + '\n' + sha256(data),
                			url = 'https://' + host + canonical_uri;
                
                		var credential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',
                			request_string = 'AWS4-HMAC-SHA256' + '\n' + amzdate + '\n' + credential_scope + '\n' + sha256(canonical_request),
                			key = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);
                
                		key = AWS.sign(key, region);
                		key = AWS.sign(key, service);
                		key = AWS.sign(key, 'aws4_request');
                
                		var request = new HttpRequest();
                
                		if (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {
                			request.setProxy(AWS.params.proxy);
                		}
                		request.addHeader('x-amz-date: ' + amzdate);
                		request.addHeader('x-amz-content-sha256:' + sha256(data));
                		request.addHeader('X-Amz-Target: GraniteServiceVersion20100801.GetMetricData')
                		request.addHeader('Accept: application/json');
                		request.addHeader('Content-Type: application/json');
                		request.addHeader('Content-Encoding: amz-1.0');
                		request.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));
                		if (AWS.params.auth_type === 'role_base')
                			request.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);
                
                
                		url = 'https://' + host + '/';
                		Zabbix.log(4, '[ AWS ELB ] Sending request: ' + url);
                		response = request.post(url, data);
                		Zabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);
                		if (request.getStatus() !== 200) {
                			throw 'Request failed with status code ' + request.getStatus() + ': ' + response;
                		}
                
                		return JSON.parse(response);
                	},
                
                	getMetricsData: function () {
                		var end_time = Math.floor((new Date().getTime()) / 1000),
                			start_time = end_time - AWS.request_period * 60;
                		payload = {
                			'StartTime': start_time,
                			'EndTime': end_time,
                			'ScanBy': 'TimestampDescending',
                			'MetricDataQueries': AWS.renderMetricQuery(AWS.request_period, AWS.params.arn, AWS.params.target_arn),
                		}
                		return AWS.getField(AWS.request('POST', AWS.params.region, 'monitoring', payload), 'MetricDataResults');
                	}
                
                };
                
                try {
                	AWS.setParams(JSON.parse(value));
                	return JSON.stringify(AWS.getMetricsData());
                }
                catch (error) {
                	error += (String(error).endsWith('.')) ? '' : '.';
                	Zabbix.log(3, '[ AWS ELB Get targets group metrics] ERROR: ' + error);
                
                	return JSON.stringify({ 'error': error });
                }
              description: |
                Get metrics of ELB ["{#AWS.ELB.TARGET.GROUP.NAME}"] target group.
                Full metrics list related to AWS ELB: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html#user-authentication-metric-table
              preprocessing:
                - type: CHECK_NOT_SUPPORTED
                  parameters:
                    - ''
              timeout: 15s
              parameters:
                - name: AccessKeyId
                  value: '{$AWS.ACCESS.KEY.ID}'
                - name: arn
                  value: '{$AWS.ELB.ARN}'
                - name: auth_type
                  value: '{$AWS.AUTH_TYPE}'
                - name: proxy
                  value: '{$AWS.PROXY}'
                - name: region
                  value: '{$AWS.REGION}'
                - name: SecretAccessKey
                  value: '{$AWS.SECRET.ACCESS.KEY}'
                - name: target_arn
                  value: '{#AWS.ELB.TARGET.GROUP.ARN}'
              tags:
                - tag: component
                  value: raw
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: e4cd95136bb04981b15a508aa73f5723
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy Host'
              type: DEPENDENT
              key: 'aws.elb.target_groups.healthy_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered healthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: b96ad1d2f5064cc99c49eeec3801418e
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State DNS'
              type: DEPENDENT
              key: 'aws.elb.target_groups.healthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that meet the DNS healthy state requirements.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyStateDNS")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 030c4fe8b7f44bf3a290b1b5da9319d8
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State Routing'
              type: DEPENDENT
              key: 'aws.elb.target_groups.healthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that meet the routing healthy state requirements.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HealthyStateRouting")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: fa9da54b4feb4fc79fbf74c491eb23ba
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: HTTP Code Target 2XX'
              type: DEPENDENT
              key: 'aws.elb.target_groups.http_2xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_2XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 2xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 50e78304f9e74019b7e06310d6dd2e6f
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: HTTP Code Target 3XX'
              type: DEPENDENT
              key: 'aws.elb.target_groups.http_3xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_3XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 3xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: ec7b92c79c6f441cadb8994b906753f4
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: HTTP Code Target 4XX'
              type: DEPENDENT
              key: 'aws.elb.target_groups.http_4xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_4XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 4xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: c9e61f9d2f12496d90693a83cb829b66
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: HTTP Code Target 5XX'
              type: DEPENDENT
              key: 'aws.elb.target_groups.http_5xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The number of HTTP response codes generated by the targets.
                This does not include any response codes generated by the load balancer.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "HTTPCode_Target_5XX_Count")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: http
                - tag: component
                  value: target-groups
                - tag: http-code
                  value: 5xx
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 0ad4d9a933944c7d979da411d24b165e
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Mitigated Host'
              type: DEPENDENT
              key: 'aws.elb.target_groups.mitigated_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets under mitigation.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "MitigatedHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 31a579ac8de9402bae3a3668779ec6c5
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Request Count Per Target'
              type: DEPENDENT
              key: 'aws.elb.target_groups.request["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: |
                The average request count per target, in a target group.
                You must specify the target group using the TargetGroup dimension.
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "RequestCountPerTarget")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: requests
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: c158172738084d38aec424505a7a86a5
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy Host'
              type: DEPENDENT
              key: 'aws.elb.target_groups.unhealthy_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of targets that are considered unhealthy.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnHealthyHostCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 9fea4b63067445d98d29de566d50b0a4
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy Routing Request'
              type: DEPENDENT
              key: 'aws.elb.target_groups.unhealthy_routing_request["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The average request count per target, in a target group.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyRoutingRequestCount")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: requests
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: f050e9610eb64251b55e843fc5eb5876
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy State DNS'
              type: DEPENDENT
              key: 'aws.elb.target_groups.unhealthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that do not meet the DNS healthy state requirements and therefore were marked unhealthy in DNS.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyStateDNS")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
            - uuid: 2a446451893e4f70a0d4ac4b1bb969fb
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy State Routing'
              type: DEPENDENT
              key: 'aws.elb.target_groups.unhealthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              delay: '0'
              history: 7d
              description: 'The number of zones that do not meet the routing healthy state requirements, and therefore the load balancer distributes traffic to all targets in the zone, including the unhealthy targets.'
              preprocessing:
                - type: JSONPATH
                  parameters:
                    - '$.[?(@.Label == "UnhealthyStateRouting")].Values.first().first()'
                  error_handler: DISCARD_VALUE
              master_item:
                key: 'aws.elb.target_groups.get_metrics["{#AWS.ELB.TARGET.GROUP.NAME}"]'
              tags:
                - tag: component
                  value: health
                - tag: component
                  value: target-groups
                - tag: protocol
                  value: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
                - tag: target-group
                  value: '{#AWS.ELB.TARGET.GROUP.NAME}'
                - tag: type
                  value: '{#AWS.ELB.TARGET.GROUP.TYPE}'
          graph_prototypes:
            - uuid: f426eff334d449ff9ec0a2ff8f6ee103
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.healthy_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: f6f8d317322a420ab4e0025b3b284a98
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State DNS'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.healthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 40922ff1845141c7a2488fe24debeae0
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State Routing'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.healthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: a2668f5bf6a240a296b047c1b979f9dc
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy Host'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.unhealthy_host["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 54645b74585c4b45a971c13d1127698d
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]:  Unhealthy State DNS'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.unhealthy_state_dns["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: 8da12e20218e4367968b8fcf0f56991a
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy State Routing'
              graph_items:
                - drawtype: GRADIENT_LINE
                  color: FF0000
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.unhealthy_state_routing["{#AWS.ELB.TARGET.GROUP.NAME}"]'
            - uuid: ec38c670cabf422ea79f41866c90ee66
              name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"] HTTP Code Target Group'
              graph_items:
                - drawtype: BOLD_LINE
                  color: 199C0D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.http_2xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '1'
                  drawtype: BOLD_LINE
                  color: F63100
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.http_3xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '2'
                  drawtype: BOLD_LINE
                  color: 00611C
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.http_4xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
                - sortorder: '3'
                  drawtype: BOLD_LINE
                  color: F7941D
                  item:
                    host: 'AWS ELB Application Load Balancer by HTTP'
                    key: 'aws.elb.target_groups.http_5xx["{#AWS.ELB.TARGET.GROUP.NAME}"]'
          master_item:
            key: aws_elb_get_target_groups
          lld_macro_paths:
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.ARN}'
              path: $.target_arn
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.NAME}'
              path: $.target_name
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.PROTOCOL}'
              path: $.protocol
            - lld_macro: '{#AWS.ELB.TARGET.GROUP.TYPE}'
              path: $.type
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 3h
      tags:
        - tag: class
          value: software
        - tag: target
          value: alb
        - tag: target
          value: aws
        - tag: target
          value: elb
      macros:
        - macro: '{$AWS.ACCESS.KEY.ID}'
          description: 'Access key ID.'
        - macro: '{$AWS.AUTH_TYPE}'
          value: access_key
          description: 'Authorization method. Possible values: role_base, access_key.'
        - macro: '{$AWS.DATA.TIMEOUT}'
          value: 60s
          description: 'A response timeout for an API.'
        - macro: '{$AWS.ELB.ARN}'
          description: 'The Amazon Resource Names (ARN) of the load balancer.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_NAME.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable alarms by namespace.'
        - macro: '{$AWS.ELB.LLD.FILTER.ALARM_SERVICE_NAMESPACE.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered alarms by nanamespaceme.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.MATCHES}'
          value: '.*'
          description: 'Filter of discoverable target groups by name.'
        - macro: '{$AWS.ELB.LLD.FILTER.TARGET.GROUP.NOT_MATCHES}'
          value: CHANGE_IF_NEEDED
          description: 'Filter to exclude discovered target groups by name.'
        - macro: '{$AWS.HTTP.4XX.FAIL.MAX.WARN}'
          value: '5'
          description: 'The maximum number of HTTP request failures for a trigger expression.'
        - macro: '{$AWS.HTTP.5XX.FAIL.MAX.WARN}'
          value: '5'
          description: 'The maximum number of HTTP request failures for a trigger expression.'
        - macro: '{$AWS.PROXY}'
          description: 'Sets HTTP proxy value. If this macro is empty then no proxy is used.'
        - macro: '{$AWS.REGION}'
          value: us-west-1
          description: 'AWS Application Load balancer Region code.'
        - macro: '{$AWS.SECRET.ACCESS.KEY}'
          description: 'Secret access key.'
      dashboards:
        - uuid: 1020fa347dd24a2ba4091528e63639d4
          name: 'Overview AWS ELB Application Load Balancer'
          pages:
            - name: 'AWS ALB: Metrics'
              widgets:
                - type: GRAPH_CLASSIC
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB: HTTP Code'
                - type: GRAPH_CLASSIC
                  'y': '5'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB: Connection Count'
                - type: GRAPH_CLASSIC
                  'y': '10'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB: Requests Count and Response Time'
                - type: GRAPH_CLASSIC
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: GRAPH
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB: Consumed LCUs and Processed Bytes'
            - name: 'AWS ALB Target Groups: Metrics'
              widgets:
                - type: GRAPH_PROTOTYPE
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy Host'
                - type: GRAPH_PROTOTYPE
                  'y': '5'
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State Routing'
                - type: GRAPH_PROTOTYPE
                  'y': '10'
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Healthy State DNS'
                - type: GRAPH_PROTOTYPE
                  'y': '15'
                  width: '24'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"] HTTP Code Target Group'
                - type: GRAPH_PROTOTYPE
                  x: '12'
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy Host'
                - type: GRAPH_PROTOTYPE
                  x: '12'
                  'y': '5'
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]: Unhealthy State Routing'
                - type: GRAPH_PROTOTYPE
                  x: '12'
                  'y': '10'
                  width: '12'
                  height: '5'
                  fields:
                    - type: INTEGER
                      name: columns
                      value: '1'
                    - type: GRAPH_PROTOTYPE
                      name: graphid
                      value:
                        host: 'AWS ELB Application Load Balancer by HTTP'
                        name: 'AWS ALB Target Groups: ["{#AWS.ELB.TARGET.GROUP.NAME}"]:  Unhealthy State DNS'
      valuemaps:
        - uuid: 4bb749152d5d452ead36c5a98c3cac16
          name: 'Alarm state'
          mappings:
            - value: '0'
              newvalue: OK
            - value: '1'
              newvalue: 'Insufficient data'
            - value: '2'
              newvalue: Alarm
            - value: '255'
              newvalue: Unknown
  graphs:
    - uuid: b19f7d65ad1d469d8396b03111d38e52
      name: 'AWS ALB: Connection Count'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.active_connection
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.new_connection
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.rejected_Connection
        - sortorder: '3'
          drawtype: BOLD_LINE
          color: F7941D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.target_connection_error
    - uuid: fb034590cbc34b0aa297b77c1f320684
      name: 'AWS ALB: Consumed LCUs and Processed Bytes'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.capacity_units
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.processed_bytes
    - uuid: a711d08edbd04abe890ab2b8cdf6d41b
      name: 'AWS ALB: HTTP Code'
      graph_items:
        - drawtype: BOLD_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.http_3xx
        - sortorder: '1'
          drawtype: BOLD_LINE
          color: F63100
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.http_4xx
        - sortorder: '2'
          drawtype: BOLD_LINE
          color: 00611C
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.http_5xx
    - uuid: 4ee7ac4174b74f869e04dab5d76219ab
      name: 'AWS ALB: Requests Count and Response Time'
      graph_items:
        - drawtype: GRADIENT_LINE
          color: 199C0D
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.requests
        - sortorder: '1'
          drawtype: GRADIENT_LINE
          color: F63100
          yaxisside: RIGHT
          item:
            host: 'AWS ELB Application Load Balancer by HTTP'
            key: aws.elb.target_response_time
